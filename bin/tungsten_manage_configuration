#!/usr/bin/env ruby
# Copyright (C) 2014 Continuent, Inc.
# 
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License.  You may obtain
# a copy of the License at
# 
#         http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
# License for the specific language governing permissions and limitations
# under the License.
#
# Initial developer(s): Jeff Mace
# Contributor(s):

# TODO : Add hooks
# TODO : Think about rollback after copying in the new INI file
# TODO : Add a mechanism to include service specific configuration information
# TODO : Add a 'repair' command that will reprovision or change the slave URI

begin
  require 'rubygems'
  gem 'continuent-tools-core'
rescue LoadError
end

require 'continuent-tools-core'
require 'digest/md5'

class TungstenManageConfiguration
  include TungstenScript
  private
  
  SERVER_TYPE = "tungsten-ServerType"
  CLUSTER_NAME = "tungsten-ClusterName"
  COMPOSITE_CLUSTER_NAME = "tungsten-CompositeClusterName"
  COMPOSITE_CLUSTER_MASTER = "tungsten-CompositeClusterMaster"
  ARCHIVE_CLUSTERS = "tungsten-ArchiveClusters"
  CONNECTOR_CLUSTERS = "tungsten-ConnectorClusters"
  
  def main
    directory_entries = load_directory_entries()
    entry_key = find_directory_entry_key(directory_entries, opt(:hostname))
    entry = directory_entries[entry_key]
    validate_entry(entry)
    unless TU.is_valid?()
      return
    end
    
    services = generate_services_map(directory_entries)
    
    case command()
    when "install"
      install_entry(services, entry)
    when "uninstall"
      uninstall_entry(entry)
    end
  end
  
  def install_entry(services, entry)
    entry_services = filter_services_map(services, entry)
    pending_ini = write_ini_configuration(entry_services, entry)

    # Rewind and calculate the pending INI md5sum
    pending_ini.rewind()
    pending_md5sum = Digest::MD5.hexdigest(pending_ini.read())
    pending_contents = TU.parse_ini_file(pending_ini.path())
    validate_pending_ini_contents(entry, pending_contents)
    unless TU.is_valid?()
      return
    end
    
    # Calculate the starting signature and contents of the INI file
    initial_md5sum = nil
    initial_contents = nil
    if File.exists?(opt(:outputfile))
      File.open(opt(:outputfile), "r") {
        |f|
        initial_md5sum = Digest::MD5.hexdigest(f.read())
      }
      initial_contents = TU.parse_ini_file(opt(:outputfile))
    end
    
    # Add a diff to the debug log for review purposes
    TU.cmd_result("diff -u #{opt(:outputfile)} #{pending_ini.path()}", true)

    types = entry["tags"][SERVER_TYPE]
    if initial_md5sum != pending_md5sum || opt(:replace_release) == true
      if opt(:log) != nil
        TU.set_log_path(opt(:log))
      end
      
      TU.info("Update the INI file and system configuration")
      FileUtils.cp(pending_ini.path(), opt(:outputfile))
      FileUtils.cp(pending_ini.path(), get_original_file(opt(:outputfile)))
      
      if types.include?("datasource") || types.include?("connector")
        home = opt(:continuent_tungsten_home)
        TU.mkdir_if_absent("#{home}/service_logs")
        tpmlog = "#{home}/service_logs/tungsten-configure.log"
        
        if File.exists?("#{home}/tungsten")
          exists = true
          begin
            TU.notice("Update #{home}/tungsten")
            TU.cmd_result("#{opt(:continuent_tungsten_home)}/tungsten/tools/tpm update --tty --log=#{tpmlog}")
          rescue CommandError => ce
            TU.debug(ce)
            raise "Unable to update Continuent Tungsten check #{tpmlog} for more information"
          end
        else
          exists = false
          
          begin
            TU.notice("Install #{opt(:continuent_tungsten_package)}")
            TU.cmd_result("#{opt(:continuent_tungsten_package)}/tools/tpm install --tty --log=#{tpmlog}")
          rescue CommandError => ce
            TU.debug(ce)
            raise "Unable to install Continuent Tungsten check #{tpmlog} for more information"
          end
          
          install = TungstenInstall.new("#{home}/tungsten")
          if types.include?("datasource")
            begin
              available_replicators = JSON.parse(TU.cmd_result("#{home}/tungsten/tungsten-replicator/scripts/multi_trepctl --paths=self --output=json --fields=*"))
            rescue CommandError => ce
              TU.debug(ce)
              raise "Unable to find other replicators running in this cluster. Try running `#{script_name()} repair`."
            end
            
            if available_replicators.size() > 0
              master_uri = nil
              relay_uri = nil
              available_replicators.each{
                |r|
                if r["role"] == "master"
                  master_uri = r["masterListenUri"]
                elsif r["role"] == "relay"
                  relay_uri = r["masterListenUri"]
                end
              }
              
              if master_uri == nil && relay_uri != nil
                master_uri = relay_uri
              end
              
              dynamic_path = install.setting(install.setting_key(REPL_SERVICES, entry["tags"][CLUSTER_NAME], 'repl_svc_dynamic_config'))
              if dynamic_path.to_s() == ""
                raise "Unable to set the replication URI because the dynamic properties file could not be found. Try running `#{script_name()} repair`."
              end
              File.open(dynamic_path, "w") {
                |f|
                f.puts("replicator.master.connect.uri=#{master_uri}")
                f.puts("replicator.role=slave")
              }

              TU.notice("Provisioning the server. This may take some time.")
              TU.cmd_result("#{home}/tungsten/tungsten-replicator/scripts/tungsten_provision_slave --source=autodetect")
            end
          end
        end
        
        TU.notice("Start Continuent Tungsten")
        TU.cmd_result("#{home}/tungsten/cluster-home/bin/startall")
        # TODO: Check that everything has started
        
        # TODO: Identify missing datasources and remove them from the cluster
      end
      
      if types.include?("archive")
        home = opt(:tungsten_replicator_home)
        TU.mkdir_if_absent("#{home}/service_logs")
        tpmlog = "#{home}/service_logs/tungsten-configure.log"
        
        if File.exists?("#{home}/tungsten")
          exists = true
          begin
            TU.notice("Update #{home}/tungsten")
            TU.cmd_result("#{opt(:tungsten_replicator_home)}/tungsten/tools/tpm update --tty --log=#{tpmlog}")
          rescue CommandError => ce
            TU.debug(ce)
            raise "Unable to update Tungsten Replicator check #{tpmlog} for more information"
          end
        else
          exists = false
          
          begin
            TU.notice("Install #{opt(:tungsten_replicator_package)}")
            TU.cmd_result("#{opt(:tungsten_replicator_package)}/tools/tpm install --tty --log=#{tpmlog}")
          rescue CommandError => ce
            TU.debug(ce)
            raise "Unable to install Tungsten Replicator check #{tpmlog} for more information"
          end
          
          # TODO: Provision the server if it isn't a datasource
          
          TU.notice("Start Tungsten Replicator")
          TU.cmd_result("#{home}/tungsten/cluster-home/bin/startall")
        end
      end
    else
      TU.notice("There are no changes to the INI file")
    end
    
    if types.include?("connector")
      # TODO: Create a users.map file
    end
  end
  
  def uninstall_entry(entry)
    if opt(:log) != nil
      TU.set_log_path(opt(:log))
    end
    
    types = entry["tags"][SERVER_TYPE]
    
    if types.include?("datasource") || types.include?("connector")
      begin
        TU.notice("Uninstall #{opt(:continuent_tungsten_package)}")
        TU.cmd_result("#{opt(:continuent_tungsten_package)}/tools/tpm uninstall --i-am-sure")
      rescue CommandError => ce
        TU.debug(ce)
        TU.error "Unable to uninstall Continuent Tungsten"
      end
    end
    
    if types.include?("archive")
      begin
        TU.notice("Uninstall #{opt(:tungsten_replicator_package)}")
        TU.cmd_result("#{opt(:tungsten_replicator_package)}/tools/tpm uninstall --i-am-sure")
      rescue CommandError => ce
        TU.debug(ce)
        TU.error "Unable to uninstall Tungsten Replicator"
      end
    end
    
    TU.cmd_result("rm -f #{opt(:outputfile)}")
    TU.cmd_result("rm -f #{get_original_file(opt(:outputfile))}")
  end
  
  # Returns a parsed version of the output from tungsten_directory
  def load_directory_entries
    begin
      json = TU.cmd_result("tungsten_directory")
    rescue CommandError => ce
      raise MessageError.new("Unable to manage configuration because the tungsten_directory command failed")
    end
    
    begin
      entries = JSON.parse(json)
    rescue
      entries = nil
    end
    
    unless entries.is_a?(Hash)
      raise MessageError.new("Unable to manage configuration because the tungsten_directory command did not return valid JSON")
    end
    
    return entries
  end
  
  # Find the hash key that matches this hostname
  def find_directory_entry_key(entries, hostname)
    entries.each{
      |k,v|
      if v["hostname"] == hostname
        return k
      end
    }
    
    raise MessageError.new("Unable to find a directory entry for '#{hostname}'")
  end
  
  # Take the information from tungsten_directory and turn it into
  # a set of cluster data that could be written to the INI file
  def generate_services_map(entries)
    map = {}
    is_valid = true
    
    entries.each{
      |k,entry|
      types = entry["tags"][SERVER_TYPE]
      unless types.is_a?(Array)
        types = [types]
      end
      
      types.each{
        |type|
        begin
          case type
          when "datasource"
            generate_datasource_services_map(map, entry)
          when "connector"
            generate_connector_services_map(map, entry)
          when "archive"
            generate_archive_services_map(map, entry)
          else
            raise MessageError.new("Unable to process a #{SERVER_TYPE} of #{type} for #{entry["hostname"]}")
          end
        rescue MessageError => me
          is_valid = false
          TU.error(me.message)
        end
      }
    }
    
    unless is_valid == true
      raise MessageError.new("Unable to proceed due to issues with the directory entries")
    end
    
    map
  end
  
  def generate_datasource_services_map(map, entry)
    svc = entry["tags"][CLUSTER_NAME]
    if svc.to_s() == ""
      raise MessageError.new "Unable to create the cluster on #{entry['hostname']} because it does not have a value for the '#{CLUSTER_NAME}' tag."
    end
    
    unless map.has_key?(svc)
      map[svc] = {}
    end
    unless map[svc].has_key?("members")
      map[svc]["members"] = []
    end
    
    # Initiate the cluster
    map[svc]["topology"] = "clustered"
    
    # Add the host to the cluster
    map[svc]["members"] << entry["hostname"]
    map[svc]["members"].uniq!()
    map[svc]["members"].sort!()
    
    composite_svc = entry["tags"][COMPOSITE_CLUSTER_NAME]
    if composite_svc.to_s() != ""
      unless map.has_key?(composite_svc)
        map[composite_svc] = {}
      end
      unless map[composite_svc].has_key?("composite-datasources")
        map[composite_svc]["composite-datasources"] = []
      end
      
      # Add this cluster to the composite cluster
      map[composite_svc]["composite-datasources"] << svc
      
      # Define the replication relay source for this cluster
      composite_master = entry["tags"][COMPOSITE_CLUSTER_MASTER]
      if composite_master.to_s() == ""
        raise MessageError.new "Unable to create the '#{composite_svc}' composite cluster because #{entry['hostname']} does not define the '#{COMPOSITE_CLUSTER_MASTER}' tag."
      end
      
      # Set relay-source if this cluster is not the master
      # Throw an error if another cluster has specified a different
      # composite cluster master
      unless map[svc].has_key?("relay-source")
        unless composite_master == svc
          map[svc]["relay-source"] = composite_master
        end
      else
        if composite_master != map[svc]["relay-source"]
          raise MessageError.new "Unable to create the '#{composite_svc}' composite cluster because #{entry['hostname']} defines a different '#{COMPOSITE_CLUSTER_MASTER}' than other hosts."
        end
      end
    end
  end
  
  def generate_connector_services_map(map, entry)
    services = entry["tags"][CONNECTOR_CLUSTERS]
    if services.to_s() == ""
      services = entry["tags"][CLUSTER_NAME]
    end
    if services.to_s() == ""
      raise MessageError.new "Unable to create the connector on #{entry['hostname']} because it does not have a value for the '#{CONNECTOR_CLUSTERS}' tag."
    end
    
    unless services.is_a?(Array)
      services = services.split(",")
    end
    services.each{
      |svc|
      unless map.has_key?(svc)
        map[svc] = {}
      end
      unless map[svc].has_key?("connectors")
        map[svc]["connectors"] = []
      end
      
      # Add this host to each cluster
      map[svc]["connectors"] << entry["hostname"]
    }
  end
  
  def generate_archive_services_map(map, entry)
    services = entry["tags"][ARCHIVE_CLUSTERS]
    if services.to_s() == ""
      raise MessageError.new "Unable to create the archive replicator on #{entry['hostname']} because it does not have a value for the '#{ARCHIVE_CLUSTERS}' tag."
    end
    
    unless services.is_a?(Array)
      services = services.split(",")
    end
    services.each{
      |svc|
      svc_alias = "#{svc}_slave"
      unless map.has_key?(svc_alias)
        map[svc_alias] = {}
      end
      unless map[svc_alias].has_key?("members")
        map[svc_alias]["members"] = []
      end
      
      # Initiate the cluster-slave service
      map[svc_alias]["master-dataservice"] = svc
      map[svc_alias]["topology"] = "cluster-slave"
      
      # Add this host to the list of servers that is 
      # replicating from the cluster
      map[svc_alias]["members"] << entry["hostname"]
    }
  end
  
  # Remove any services that aren't required for the given entry
  def filter_services_map(map, entry)
    # Filter the services down to the services that are needed to configure 
    # this server
    allowed_services = []
    # - Services it is a member or connector of
    unless entry["tags"][CLUSTER_NAME].to_s() == ""
      allowed_services << entry["tags"][CLUSTER_NAME].to_s()
    end
    services = entry["tags"][CONNECTOR_CLUSTERS]
    unless services.to_s() == ""
      unless services.is_a?(Array)
        services = services.split(",")
      end
      services.each{
        |svc|
        allowed_services << svc
      }
    end
    # - Services that are part of its composite cluster
    unless entry["tags"][COMPOSITE_CLUSTER_NAME].to_s() == ""
      allowed_services << entry["tags"][COMPOSITE_CLUSTER_NAME].to_s()
      allowed_services = allowed_services + 
        services[entry["tags"][COMPOSITE_CLUSTER_NAME].to_s()]["composite-datasources"]
    end
    # - Services that it replicates from
    services = entry["tags"][ARCHIVE_CLUSTERS]
    unless services.to_s() == ""
      unless services.is_a?(Array)
        services = services.split(",")
      end
      services.each{
        |svc|
        allowed_services << svc
        allowed_services << "#{svc}_slave"
      }
    end
    
    # Remove any services that aren't needed
    map.delete_if {
      |k,v|
      (allowed_services.include?(k) == false)
    }
    
    map.keys().each{
      |svc|
      # The cluster-slave topology just needs to know about itself
      # Including other entries may cause extra replicator restarts
      if map[svc]["topology"] == "cluster-slave"
        map[svc]["members"].delete_if{|v| v != entry["hostname"]}
      elsif map[svc]["topology"] == "clustered"
        map[svc]["master"] = map[svc]["members"].sort()[0]
      end
    }
    
    if map.keys().size() == 0
      raise MessageError.new("Unable to manage configuration because there are no services defined for #{entry['hostname']}")
    end
    
    return map
  end
  
  # Create an INI file that is full sorted and optimized for the host
  def write_ini_configuration(map, entry)
    ini = Tempfile.new('tmcini')
    ini.puts("# DO NOT MODIFY BY HAND")
    ini.puts("# This file is managed by #{script_name()} for #{entry['hostname']}")
    ini.puts("# Any manual changes to this file will disable script execution")
    
    # TODO : Parse default INI files and ensure basic values are set
    #        Print the result in a sorted fashion after sections defaults
    #        and defaults.replicator
    @defaults_files.sort().each{
      |path|
      File.open(path, "r").each{
        |line|
        ini.puts(line.chomp())
      }
    }
    
    # Output each of the services with the keys sorted so they 
    # come out in a consistent order
    map.keys().sort().each{
      |svc|
      ini.puts("")
      ini.puts("[#{svc}]")
      
      # Print all configuration values in a sorted order
      map[svc].keys().sort().each{
        |key|
        value = map[svc][key]
        if value.is_a?(Array)
          value = value.uniq().sort().join(",")
        end
        
        ini.puts("#{key}=#{value}")
      }
    }
    
    return ini
  end
  
  def configure
    super()
    
    require_installed_directory?(false)
    
    add_option(:defaults, {
      :on => "--defaults String",
      :help => "Path to file containing the default sections of the tungsten.ini file",
      :default => "/etc/tungsten/defaults.tungsten.ini"
    })
    
    add_option(:outputfile, {
      :on => "--output-file String",
      :help => "Path to file containing the default sections of the tungsten.ini file",
      :default => "/etc/tungsten/tungsten.ini"
    })
    
    add_option(:hostname, {
      :on => "--hostname String",
      :help => "Write the INI file for this hostname",
      :default => TU.hostname()
    })
    
    add_option(:continuent_tungsten_package, {
      :on => "--continuent-tungsten-package String",
      :help => "Path to the Continuent Tungsten package to be installed"
    })
    
    add_option(:tungsten_replicator_package, {
      :on => "--tungsten-replicator-package String",
      :help => "Path to the Tungsten Replicator package to be installed"
    })
    
    add_option(:replace_release, {
      :on => "--replace-release String",
      :parse => method(:parse_boolean_option),
      :help => "Force the script to run tpm update or install even if there are no changes to the INI file",
    })
    
    add_option(:log, {
      :on => "--log String",
      :help => "Log debug output to this file for every run that modifies system configuration",
    })
    
    add_option(:lastrun, {
      :on => "--lastrun String",
      :help => "A file to store the exit code for the last run of this script",
    })
    
    add_command(:install, {
      :help => "Write the INI configuration file and install/update software",
      :default => true
    })
    
    add_command(:uninstall, {
      :help => "Remove managed software from this system"
    })
  end
  
  def validate
    super()
    
    unless TU.is_valid?()
      return TU.is_valid?()
    end
    
    unless File.exists?("/etc/tungsten") && File.writable?("/etc/tungsten")
      TU.error("The /etc/tungsten directory either does not exist or is not writeable")
    end
    
    # Make sure that the tungsten.ini file is managed if it exists
    if File.exists?(opt(:outputfile))
      matched_lines = TU.cmd_result("grep #{script_name()} /etc/tungsten/tungsten.ini | wc -l")
      if matched_lines == "0"
        TU.error("Unable to manage #{opt(:outputfile)} because it already exists and was not created by #{script_name()}")
      else
        # If it doesn't match .tungsten.ini.orig then changes have been made
        original_file = get_original_file(opt(:outputfile))
        
        if File.exists?(original_file)
          begin
            file_differences = TU.cmd_result("diff -u #{original_file} #{opt(:outputfile)}")
            # No differences
          rescue CommandError => ce
            if ce.rc == 1
              TU.error("Unable to manage #{opt(:outputfile)} because changes to it have been made manually")
            else
              raise ce
            end
          end
        else
          TU.error("Unable to manage #{opt(:outputfile)} because the tracking version #{original_file} is no longer available")
        end
      end
    end
    
    if command() == "install"
      @defaults_files = []    
      Dir.glob(opt(:defaults)).each{
        |f|
        @defaults_files << f
      }

      if @defaults_files.size() == 0
        TU.error("Unable to find any defaults files at #{opt(:defaults)}")
      end
      
      if opt(:continuent_tungsten_package) != nil
        unless File.exists?(opt(:continuent_tungsten_package))
          TU.error("Unable to find the Continuent Tungsten package at #{opt(:continuent_tungsten_package)}")
        end
      end
    
      if opt(:tungsten_replicator_package) != nil
        unless File.exists?(opt(:tungsten_replicator_package))
          TU.error("Unable to find the Tungsten Replicator package at #{opt(:tungsten_replicator_package)}")
        end
      end
    elsif command() == "uninstall"
      unless File.exists?(opt(:outputfile))
        TU.error("Unable to uninstall because #{opt(:outputfile)} isn't managed by #{script_name()}")
      end
    end
  end
  
  # Check the server types for this host and validate we have enough information
  def validate_entry(entry)
    types = entry["tags"][SERVER_TYPE]
    
    if types.include?("datasource") || types.include?("connector")
      unless opt(:continuent_tungsten_package) != nil
        TU.error("Unable to manage #{opt(:hostname)} because it includes the 'datasource' or 'connector' #{SERVER_TYPE} tag and no argument was given for --continuent-tungsten-package")
      end
    end
    
    if types.include?("archive")
      unless opt(:tungsten_replicator_package)
        TU.error("Unable to manage #{opt(:hostname)} because it includes the 'archive' #{SERVER_TYPE} tag and no argument was given for --tungsten-replicator-package")
      end
    end
  end
  
  def validate_pending_ini_contents(entry, pending_contents)
    types = entry["tags"][SERVER_TYPE]
    ini = Properties.new()
    ini.props = pending_contents
    
    if types.include?("datasource") || types.include?("connector")
      continuent_tungsten_home = ini.getProperty(["defaults", "home-directory"])
      if continuent_tungsten_home == nil
        continuent_tungsten_home = ini.getProperty(["defaults", "install-directory"])
      end
      if continuent_tungsten_home == nil
        TU.error("Unable to manage #{opt(:hostname)} because it includes the 'datasource' or 'connector' #{SERVER_TYPE} tag but the INI defaults do not include a value for 'home-directory' under '[defaults]'.")
      else
        opt(:continuent_tungsten_home, continuent_tungsten_home)
      end
    end
    
    if types.include?("archive")
      tungsten_replicator_home = ini.getProperty(["defaults.replicator", "home-directory"])
      if tungsten_replicator_home == nil
        tungsten_replicator_home = ini.getProperty(["defaults.replicator", "install-directory"])
      end
      if tungsten_replicator_home == nil
        TU.error("Unable to manage #{opt(:hostname)} because it includes the 'archive' #{SERVER_TYPE} tag but the INI defaults do not include a value for 'home-directory' under '[defaults.replicator]'.")
      else
        opt(:tungsten_replicator_home, tungsten_replicator_home)
      end
      
      if ini.getProperty(["defaults.replicator", "rmi-port"]) == nil
        TU.error("Unable to manage #{opt(:hostname)} because it includes the 'archive' #{SERVER_TYPE} tag but the INI defaults do not include a value for 'rmi-port' under '[defaults.replicator]'.")
      end
    end
  end
  
  def cleanup(code = 0)
    if opt(:lastrun) != nil
      begin
        File.open(opt(:lastrun), "w") {
          |f|
          f.puts(code)
        }
      rescue => e
        TU.exception(e)
      end
    end
    
    super(code)
  end
  
  def get_original_file(file)
    File.dirname(file) + "/." + File.basename(file) + ".orig"
  end
  
  def script_name
    "tungsten_manage_configuration"
  end
  
  self.new().run()
end